// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: faiss_rpc.proto

#ifndef PROTOBUF_INCLUDED_faiss_5frpc_2eproto
#define PROTOBUF_INCLUDED_faiss_5frpc_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_faiss_5frpc_2eproto 

namespace protobuf_faiss_5frpc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_faiss_5frpc_2eproto
namespace hszofficial {
namespace faiss_rpc {
class BatchQuery;
class BatchQueryDefaultTypeInternal;
extern BatchQueryDefaultTypeInternal _BatchQuery_default_instance_;
class BatchResponse;
class BatchResponseDefaultTypeInternal;
extern BatchResponseDefaultTypeInternal _BatchResponse_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseStatus;
class ResponseStatusDefaultTypeInternal;
extern ResponseStatusDefaultTypeInternal _ResponseStatus_default_instance_;
class TopK;
class TopKDefaultTypeInternal;
extern TopKDefaultTypeInternal _TopK_default_instance_;
class Vec;
class VecDefaultTypeInternal;
extern VecDefaultTypeInternal _Vec_default_instance_;
}  // namespace faiss_rpc
}  // namespace hszofficial
namespace google {
namespace protobuf {
template<> ::hszofficial::faiss_rpc::BatchQuery* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::BatchQuery>(Arena*);
template<> ::hszofficial::faiss_rpc::BatchResponse* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::BatchResponse>(Arena*);
template<> ::hszofficial::faiss_rpc::Query* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::Query>(Arena*);
template<> ::hszofficial::faiss_rpc::Response* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::Response>(Arena*);
template<> ::hszofficial::faiss_rpc::ResponseStatus* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::ResponseStatus>(Arena*);
template<> ::hszofficial::faiss_rpc::TopK* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::TopK>(Arena*);
template<> ::hszofficial::faiss_rpc::Vec* Arena::CreateMaybeMessage<::hszofficial::faiss_rpc::Vec>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hszofficial {
namespace faiss_rpc {

enum ResponseStatus_Stat {
  ResponseStatus_Stat_SUCCEED = 0,
  ResponseStatus_Stat_FAILED = 1,
  ResponseStatus_Stat_ResponseStatus_Stat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResponseStatus_Stat_ResponseStatus_Stat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResponseStatus_Stat_IsValid(int value);
const ResponseStatus_Stat ResponseStatus_Stat_Stat_MIN = ResponseStatus_Stat_SUCCEED;
const ResponseStatus_Stat ResponseStatus_Stat_Stat_MAX = ResponseStatus_Stat_FAILED;
const int ResponseStatus_Stat_Stat_ARRAYSIZE = ResponseStatus_Stat_Stat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseStatus_Stat_descriptor();
inline const ::std::string& ResponseStatus_Stat_Name(ResponseStatus_Stat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseStatus_Stat_descriptor(), value);
}
inline bool ResponseStatus_Stat_Parse(
    const ::std::string& name, ResponseStatus_Stat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseStatus_Stat>(
    ResponseStatus_Stat_descriptor(), name, value);
}
// ===================================================================

class Vec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.Vec) */ {
 public:
  Vec();
  virtual ~Vec();

  Vec(const Vec& from);

  inline Vec& operator=(const Vec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec(Vec&& from) noexcept
    : Vec() {
    *this = ::std::move(from);
  }

  inline Vec& operator=(Vec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec* internal_default_instance() {
    return reinterpret_cast<const Vec*>(
               &_Vec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vec* other);
  friend void swap(Vec& a, Vec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec* New() const final {
    return CreateMaybeMessage<Vec>(NULL);
  }

  Vec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec& from);
  void MergeFrom(const Vec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float elements = 1;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 1;
  float elements(int index) const;
  void set_elements(int index, float value);
  void add_elements(float value);
  const ::google::protobuf::RepeatedField< float >&
      elements() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.Vec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > elements_;
  mutable int _elements_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Query* other);
  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const final {
    return CreateMaybeMessage<Query>(NULL);
  }

  Query* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target_index = 1;
  void clear_target_index();
  static const int kTargetIndexFieldNumber = 1;
  const ::std::string& target_index() const;
  void set_target_index(const ::std::string& value);
  #if LANG_CXX11
  void set_target_index(::std::string&& value);
  #endif
  void set_target_index(const char* value);
  void set_target_index(const char* value, size_t size);
  ::std::string* mutable_target_index();
  ::std::string* release_target_index();
  void set_allocated_target_index(::std::string* target_index);

  // .hszofficial.faiss_rpc.Vec query_vec = 3;
  bool has_query_vec() const;
  void clear_query_vec();
  static const int kQueryVecFieldNumber = 3;
  private:
  const ::hszofficial::faiss_rpc::Vec& _internal_query_vec() const;
  public:
  const ::hszofficial::faiss_rpc::Vec& query_vec() const;
  ::hszofficial::faiss_rpc::Vec* release_query_vec();
  ::hszofficial::faiss_rpc::Vec* mutable_query_vec();
  void set_allocated_query_vec(::hszofficial::faiss_rpc::Vec* query_vec);

  // int32 k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  ::google::protobuf::int32 k() const;
  void set_k(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.Query)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr target_index_;
  ::hszofficial::faiss_rpc::Vec* query_vec_;
  ::google::protobuf::int32 k_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.BatchQuery) */ {
 public:
  BatchQuery();
  virtual ~BatchQuery();

  BatchQuery(const BatchQuery& from);

  inline BatchQuery& operator=(const BatchQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchQuery(BatchQuery&& from) noexcept
    : BatchQuery() {
    *this = ::std::move(from);
  }

  inline BatchQuery& operator=(BatchQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchQuery* internal_default_instance() {
    return reinterpret_cast<const BatchQuery*>(
               &_BatchQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BatchQuery* other);
  friend void swap(BatchQuery& a, BatchQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchQuery* New() const final {
    return CreateMaybeMessage<BatchQuery>(NULL);
  }

  BatchQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchQuery& from);
  void MergeFrom(const BatchQuery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hszofficial.faiss_rpc.Vec query_vecs = 4;
  int query_vecs_size() const;
  void clear_query_vecs();
  static const int kQueryVecsFieldNumber = 4;
  ::hszofficial::faiss_rpc::Vec* mutable_query_vecs(int index);
  ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::Vec >*
      mutable_query_vecs();
  const ::hszofficial::faiss_rpc::Vec& query_vecs(int index) const;
  ::hszofficial::faiss_rpc::Vec* add_query_vecs();
  const ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::Vec >&
      query_vecs() const;

  // string batch_id = 1;
  void clear_batch_id();
  static const int kBatchIdFieldNumber = 1;
  const ::std::string& batch_id() const;
  void set_batch_id(const ::std::string& value);
  #if LANG_CXX11
  void set_batch_id(::std::string&& value);
  #endif
  void set_batch_id(const char* value);
  void set_batch_id(const char* value, size_t size);
  ::std::string* mutable_batch_id();
  ::std::string* release_batch_id();
  void set_allocated_batch_id(::std::string* batch_id);

  // string target_index = 2;
  void clear_target_index();
  static const int kTargetIndexFieldNumber = 2;
  const ::std::string& target_index() const;
  void set_target_index(const ::std::string& value);
  #if LANG_CXX11
  void set_target_index(::std::string&& value);
  #endif
  void set_target_index(const char* value);
  void set_target_index(const char* value, size_t size);
  ::std::string* mutable_target_index();
  ::std::string* release_target_index();
  void set_allocated_target_index(::std::string* target_index);

  // int32 k = 3;
  void clear_k();
  static const int kKFieldNumber = 3;
  ::google::protobuf::int32 k() const;
  void set_k(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.BatchQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::Vec > query_vecs_;
  ::google::protobuf::internal::ArenaStringPtr batch_id_;
  ::google::protobuf::internal::ArenaStringPtr target_index_;
  ::google::protobuf::int32 k_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.ResponseStatus) */ {
 public:
  ResponseStatus();
  virtual ~ResponseStatus();

  ResponseStatus(const ResponseStatus& from);

  inline ResponseStatus& operator=(const ResponseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStatus(ResponseStatus&& from) noexcept
    : ResponseStatus() {
    *this = ::std::move(from);
  }

  inline ResponseStatus& operator=(ResponseStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStatus* internal_default_instance() {
    return reinterpret_cast<const ResponseStatus*>(
               &_ResponseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResponseStatus* other);
  friend void swap(ResponseStatus& a, ResponseStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStatus* New() const final {
    return CreateMaybeMessage<ResponseStatus>(NULL);
  }

  ResponseStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStatus& from);
  void MergeFrom(const ResponseStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseStatus_Stat Stat;
  static const Stat SUCCEED =
    ResponseStatus_Stat_SUCCEED;
  static const Stat FAILED =
    ResponseStatus_Stat_FAILED;
  static inline bool Stat_IsValid(int value) {
    return ResponseStatus_Stat_IsValid(value);
  }
  static const Stat Stat_MIN =
    ResponseStatus_Stat_Stat_MIN;
  static const Stat Stat_MAX =
    ResponseStatus_Stat_Stat_MAX;
  static const int Stat_ARRAYSIZE =
    ResponseStatus_Stat_Stat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Stat_descriptor() {
    return ResponseStatus_Stat_descriptor();
  }
  static inline const ::std::string& Stat_Name(Stat value) {
    return ResponseStatus_Stat_Name(value);
  }
  static inline bool Stat_Parse(const ::std::string& name,
      Stat* value) {
    return ResponseStatus_Stat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .hszofficial.faiss_rpc.ResponseStatus.Stat status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::hszofficial::faiss_rpc::ResponseStatus_Stat status() const;
  void set_status(::hszofficial::faiss_rpc::ResponseStatus_Stat value);

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.ResponseStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopK : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.TopK) */ {
 public:
  TopK();
  virtual ~TopK();

  TopK(const TopK& from);

  inline TopK& operator=(const TopK& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopK(TopK&& from) noexcept
    : TopK() {
    *this = ::std::move(from);
  }

  inline TopK& operator=(TopK&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TopK& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopK* internal_default_instance() {
    return reinterpret_cast<const TopK*>(
               &_TopK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TopK* other);
  friend void swap(TopK& a, TopK& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopK* New() const final {
    return CreateMaybeMessage<TopK>(NULL);
  }

  TopK* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TopK>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TopK& from);
  void MergeFrom(const TopK& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopK* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 rank = 1;
  int rank_size() const;
  void clear_rank();
  static const int kRankFieldNumber = 1;
  ::google::protobuf::int64 rank(int index) const;
  void set_rank(int index, ::google::protobuf::int64 value);
  void add_rank(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      rank() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_rank();

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.TopK)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > rank_;
  mutable int _rank_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(NULL);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .hszofficial.faiss_rpc.ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hszofficial::faiss_rpc::ResponseStatus& _internal_status() const;
  public:
  const ::hszofficial::faiss_rpc::ResponseStatus& status() const;
  ::hszofficial::faiss_rpc::ResponseStatus* release_status();
  ::hszofficial::faiss_rpc::ResponseStatus* mutable_status();
  void set_allocated_status(::hszofficial::faiss_rpc::ResponseStatus* status);

  // .hszofficial.faiss_rpc.TopK result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  private:
  const ::hszofficial::faiss_rpc::TopK& _internal_result() const;
  public:
  const ::hszofficial::faiss_rpc::TopK& result() const;
  ::hszofficial::faiss_rpc::TopK* release_result();
  ::hszofficial::faiss_rpc::TopK* mutable_result();
  void set_allocated_result(::hszofficial::faiss_rpc::TopK* result);

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::hszofficial::faiss_rpc::ResponseStatus* status_;
  ::hszofficial::faiss_rpc::TopK* result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hszofficial.faiss_rpc.BatchResponse) */ {
 public:
  BatchResponse();
  virtual ~BatchResponse();

  BatchResponse(const BatchResponse& from);

  inline BatchResponse& operator=(const BatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchResponse(BatchResponse&& from) noexcept
    : BatchResponse() {
    *this = ::std::move(from);
  }

  inline BatchResponse& operator=(BatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchResponse* internal_default_instance() {
    return reinterpret_cast<const BatchResponse*>(
               &_BatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BatchResponse* other);
  friend void swap(BatchResponse& a, BatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchResponse* New() const final {
    return CreateMaybeMessage<BatchResponse>(NULL);
  }

  BatchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchResponse& from);
  void MergeFrom(const BatchResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hszofficial.faiss_rpc.TopK result = 3;
  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::hszofficial::faiss_rpc::TopK* mutable_result(int index);
  ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::TopK >*
      mutable_result();
  const ::hszofficial::faiss_rpc::TopK& result(int index) const;
  ::hszofficial::faiss_rpc::TopK* add_result();
  const ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::TopK >&
      result() const;

  // string batch_id = 2;
  void clear_batch_id();
  static const int kBatchIdFieldNumber = 2;
  const ::std::string& batch_id() const;
  void set_batch_id(const ::std::string& value);
  #if LANG_CXX11
  void set_batch_id(::std::string&& value);
  #endif
  void set_batch_id(const char* value);
  void set_batch_id(const char* value, size_t size);
  ::std::string* mutable_batch_id();
  ::std::string* release_batch_id();
  void set_allocated_batch_id(::std::string* batch_id);

  // .hszofficial.faiss_rpc.ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hszofficial::faiss_rpc::ResponseStatus& _internal_status() const;
  public:
  const ::hszofficial::faiss_rpc::ResponseStatus& status() const;
  ::hszofficial::faiss_rpc::ResponseStatus* release_status();
  ::hszofficial::faiss_rpc::ResponseStatus* mutable_status();
  void set_allocated_status(::hszofficial::faiss_rpc::ResponseStatus* status);

  // @@protoc_insertion_point(class_scope:hszofficial.faiss_rpc.BatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::TopK > result_;
  ::google::protobuf::internal::ArenaStringPtr batch_id_;
  ::hszofficial::faiss_rpc::ResponseStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_faiss_5frpc_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec

// repeated float elements = 1;
inline int Vec::elements_size() const {
  return elements_.size();
}
inline void Vec::clear_elements() {
  elements_.Clear();
}
inline float Vec::elements(int index) const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Vec.elements)
  return elements_.Get(index);
}
inline void Vec::set_elements(int index, float value) {
  elements_.Set(index, value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.Vec.elements)
}
inline void Vec::add_elements(float value) {
  elements_.Add(value);
  // @@protoc_insertion_point(field_add:hszofficial.faiss_rpc.Vec.elements)
}
inline const ::google::protobuf::RepeatedField< float >&
Vec::elements() const {
  // @@protoc_insertion_point(field_list:hszofficial.faiss_rpc.Vec.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedField< float >*
Vec::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:hszofficial.faiss_rpc.Vec.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// Query

// string target_index = 1;
inline void Query::clear_target_index() {
  target_index_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Query::target_index() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Query.target_index)
  return target_index_.GetNoArena();
}
inline void Query::set_target_index(const ::std::string& value) {
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.Query.target_index)
}
#if LANG_CXX11
inline void Query::set_target_index(::std::string&& value) {
  
  target_index_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hszofficial.faiss_rpc.Query.target_index)
}
#endif
inline void Query::set_target_index(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hszofficial.faiss_rpc.Query.target_index)
}
inline void Query::set_target_index(const char* value, size_t size) {
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hszofficial.faiss_rpc.Query.target_index)
}
inline ::std::string* Query::mutable_target_index() {
  
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.Query.target_index)
  return target_index_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Query::release_target_index() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.Query.target_index)
  
  return target_index_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Query::set_allocated_target_index(::std::string* target_index) {
  if (target_index != NULL) {
    
  } else {
    
  }
  target_index_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_index);
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.Query.target_index)
}

// int32 k = 2;
inline void Query::clear_k() {
  k_ = 0;
}
inline ::google::protobuf::int32 Query::k() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Query.k)
  return k_;
}
inline void Query::set_k(::google::protobuf::int32 value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.Query.k)
}

// .hszofficial.faiss_rpc.Vec query_vec = 3;
inline bool Query::has_query_vec() const {
  return this != internal_default_instance() && query_vec_ != NULL;
}
inline void Query::clear_query_vec() {
  if (GetArenaNoVirtual() == NULL && query_vec_ != NULL) {
    delete query_vec_;
  }
  query_vec_ = NULL;
}
inline const ::hszofficial::faiss_rpc::Vec& Query::_internal_query_vec() const {
  return *query_vec_;
}
inline const ::hszofficial::faiss_rpc::Vec& Query::query_vec() const {
  const ::hszofficial::faiss_rpc::Vec* p = query_vec_;
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Query.query_vec)
  return p != NULL ? *p : *reinterpret_cast<const ::hszofficial::faiss_rpc::Vec*>(
      &::hszofficial::faiss_rpc::_Vec_default_instance_);
}
inline ::hszofficial::faiss_rpc::Vec* Query::release_query_vec() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.Query.query_vec)
  
  ::hszofficial::faiss_rpc::Vec* temp = query_vec_;
  query_vec_ = NULL;
  return temp;
}
inline ::hszofficial::faiss_rpc::Vec* Query::mutable_query_vec() {
  
  if (query_vec_ == NULL) {
    auto* p = CreateMaybeMessage<::hszofficial::faiss_rpc::Vec>(GetArenaNoVirtual());
    query_vec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.Query.query_vec)
  return query_vec_;
}
inline void Query::set_allocated_query_vec(::hszofficial::faiss_rpc::Vec* query_vec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete query_vec_;
  }
  if (query_vec) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query_vec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query_vec, submessage_arena);
    }
    
  } else {
    
  }
  query_vec_ = query_vec;
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.Query.query_vec)
}

// -------------------------------------------------------------------

// BatchQuery

// string batch_id = 1;
inline void BatchQuery::clear_batch_id() {
  batch_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchQuery::batch_id() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchQuery.batch_id)
  return batch_id_.GetNoArena();
}
inline void BatchQuery::set_batch_id(const ::std::string& value) {
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.BatchQuery.batch_id)
}
#if LANG_CXX11
inline void BatchQuery::set_batch_id(::std::string&& value) {
  
  batch_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hszofficial.faiss_rpc.BatchQuery.batch_id)
}
#endif
inline void BatchQuery::set_batch_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hszofficial.faiss_rpc.BatchQuery.batch_id)
}
inline void BatchQuery::set_batch_id(const char* value, size_t size) {
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hszofficial.faiss_rpc.BatchQuery.batch_id)
}
inline ::std::string* BatchQuery::mutable_batch_id() {
  
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchQuery.batch_id)
  return batch_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchQuery::release_batch_id() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.BatchQuery.batch_id)
  
  return batch_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchQuery::set_allocated_batch_id(::std::string* batch_id) {
  if (batch_id != NULL) {
    
  } else {
    
  }
  batch_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), batch_id);
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.BatchQuery.batch_id)
}

// string target_index = 2;
inline void BatchQuery::clear_target_index() {
  target_index_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchQuery::target_index() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchQuery.target_index)
  return target_index_.GetNoArena();
}
inline void BatchQuery::set_target_index(const ::std::string& value) {
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.BatchQuery.target_index)
}
#if LANG_CXX11
inline void BatchQuery::set_target_index(::std::string&& value) {
  
  target_index_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hszofficial.faiss_rpc.BatchQuery.target_index)
}
#endif
inline void BatchQuery::set_target_index(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hszofficial.faiss_rpc.BatchQuery.target_index)
}
inline void BatchQuery::set_target_index(const char* value, size_t size) {
  
  target_index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hszofficial.faiss_rpc.BatchQuery.target_index)
}
inline ::std::string* BatchQuery::mutable_target_index() {
  
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchQuery.target_index)
  return target_index_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchQuery::release_target_index() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.BatchQuery.target_index)
  
  return target_index_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchQuery::set_allocated_target_index(::std::string* target_index) {
  if (target_index != NULL) {
    
  } else {
    
  }
  target_index_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_index);
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.BatchQuery.target_index)
}

// int32 k = 3;
inline void BatchQuery::clear_k() {
  k_ = 0;
}
inline ::google::protobuf::int32 BatchQuery::k() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchQuery.k)
  return k_;
}
inline void BatchQuery::set_k(::google::protobuf::int32 value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.BatchQuery.k)
}

// repeated .hszofficial.faiss_rpc.Vec query_vecs = 4;
inline int BatchQuery::query_vecs_size() const {
  return query_vecs_.size();
}
inline void BatchQuery::clear_query_vecs() {
  query_vecs_.Clear();
}
inline ::hszofficial::faiss_rpc::Vec* BatchQuery::mutable_query_vecs(int index) {
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchQuery.query_vecs)
  return query_vecs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::Vec >*
BatchQuery::mutable_query_vecs() {
  // @@protoc_insertion_point(field_mutable_list:hszofficial.faiss_rpc.BatchQuery.query_vecs)
  return &query_vecs_;
}
inline const ::hszofficial::faiss_rpc::Vec& BatchQuery::query_vecs(int index) const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchQuery.query_vecs)
  return query_vecs_.Get(index);
}
inline ::hszofficial::faiss_rpc::Vec* BatchQuery::add_query_vecs() {
  // @@protoc_insertion_point(field_add:hszofficial.faiss_rpc.BatchQuery.query_vecs)
  return query_vecs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::Vec >&
BatchQuery::query_vecs() const {
  // @@protoc_insertion_point(field_list:hszofficial.faiss_rpc.BatchQuery.query_vecs)
  return query_vecs_;
}

// -------------------------------------------------------------------

// ResponseStatus

// .hszofficial.faiss_rpc.ResponseStatus.Stat status = 1;
inline void ResponseStatus::clear_status() {
  status_ = 0;
}
inline ::hszofficial::faiss_rpc::ResponseStatus_Stat ResponseStatus::status() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.ResponseStatus.status)
  return static_cast< ::hszofficial::faiss_rpc::ResponseStatus_Stat >(status_);
}
inline void ResponseStatus::set_status(::hszofficial::faiss_rpc::ResponseStatus_Stat value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.ResponseStatus.status)
}

// string message = 2;
inline void ResponseStatus::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseStatus::message() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.ResponseStatus.message)
  return message_.GetNoArena();
}
inline void ResponseStatus::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.ResponseStatus.message)
}
#if LANG_CXX11
inline void ResponseStatus::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hszofficial.faiss_rpc.ResponseStatus.message)
}
#endif
inline void ResponseStatus::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hszofficial.faiss_rpc.ResponseStatus.message)
}
inline void ResponseStatus::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hszofficial.faiss_rpc.ResponseStatus.message)
}
inline ::std::string* ResponseStatus::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.ResponseStatus.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseStatus::release_message() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.ResponseStatus.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.ResponseStatus.message)
}

// -------------------------------------------------------------------

// TopK

// repeated int64 rank = 1;
inline int TopK::rank_size() const {
  return rank_.size();
}
inline void TopK::clear_rank() {
  rank_.Clear();
}
inline ::google::protobuf::int64 TopK::rank(int index) const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.TopK.rank)
  return rank_.Get(index);
}
inline void TopK::set_rank(int index, ::google::protobuf::int64 value) {
  rank_.Set(index, value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.TopK.rank)
}
inline void TopK::add_rank(::google::protobuf::int64 value) {
  rank_.Add(value);
  // @@protoc_insertion_point(field_add:hszofficial.faiss_rpc.TopK.rank)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TopK::rank() const {
  // @@protoc_insertion_point(field_list:hszofficial.faiss_rpc.TopK.rank)
  return rank_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TopK::mutable_rank() {
  // @@protoc_insertion_point(field_mutable_list:hszofficial.faiss_rpc.TopK.rank)
  return &rank_;
}

// -------------------------------------------------------------------

// Response

// .hszofficial.faiss_rpc.ResponseStatus status = 1;
inline bool Response::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void Response::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::hszofficial::faiss_rpc::ResponseStatus& Response::_internal_status() const {
  return *status_;
}
inline const ::hszofficial::faiss_rpc::ResponseStatus& Response::status() const {
  const ::hszofficial::faiss_rpc::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Response.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hszofficial::faiss_rpc::ResponseStatus*>(
      &::hszofficial::faiss_rpc::_ResponseStatus_default_instance_);
}
inline ::hszofficial::faiss_rpc::ResponseStatus* Response::release_status() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.Response.status)
  
  ::hszofficial::faiss_rpc::ResponseStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hszofficial::faiss_rpc::ResponseStatus* Response::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hszofficial::faiss_rpc::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.Response.status)
  return status_;
}
inline void Response::set_allocated_status(::hszofficial::faiss_rpc::ResponseStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.Response.status)
}

// .hszofficial.faiss_rpc.TopK result = 2;
inline bool Response::has_result() const {
  return this != internal_default_instance() && result_ != NULL;
}
inline void Response::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) {
    delete result_;
  }
  result_ = NULL;
}
inline const ::hszofficial::faiss_rpc::TopK& Response::_internal_result() const {
  return *result_;
}
inline const ::hszofficial::faiss_rpc::TopK& Response::result() const {
  const ::hszofficial::faiss_rpc::TopK* p = result_;
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.Response.result)
  return p != NULL ? *p : *reinterpret_cast<const ::hszofficial::faiss_rpc::TopK*>(
      &::hszofficial::faiss_rpc::_TopK_default_instance_);
}
inline ::hszofficial::faiss_rpc::TopK* Response::release_result() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.Response.result)
  
  ::hszofficial::faiss_rpc::TopK* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::hszofficial::faiss_rpc::TopK* Response::mutable_result() {
  
  if (result_ == NULL) {
    auto* p = CreateMaybeMessage<::hszofficial::faiss_rpc::TopK>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.Response.result)
  return result_;
}
inline void Response::set_allocated_result(::hszofficial::faiss_rpc::TopK* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.Response.result)
}

// -------------------------------------------------------------------

// BatchResponse

// .hszofficial.faiss_rpc.ResponseStatus status = 1;
inline bool BatchResponse::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void BatchResponse::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::hszofficial::faiss_rpc::ResponseStatus& BatchResponse::_internal_status() const {
  return *status_;
}
inline const ::hszofficial::faiss_rpc::ResponseStatus& BatchResponse::status() const {
  const ::hszofficial::faiss_rpc::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hszofficial::faiss_rpc::ResponseStatus*>(
      &::hszofficial::faiss_rpc::_ResponseStatus_default_instance_);
}
inline ::hszofficial::faiss_rpc::ResponseStatus* BatchResponse::release_status() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.BatchResponse.status)
  
  ::hszofficial::faiss_rpc::ResponseStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hszofficial::faiss_rpc::ResponseStatus* BatchResponse::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hszofficial::faiss_rpc::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchResponse.status)
  return status_;
}
inline void BatchResponse::set_allocated_status(::hszofficial::faiss_rpc::ResponseStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.BatchResponse.status)
}

// string batch_id = 2;
inline void BatchResponse::clear_batch_id() {
  batch_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchResponse::batch_id() const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchResponse.batch_id)
  return batch_id_.GetNoArena();
}
inline void BatchResponse::set_batch_id(const ::std::string& value) {
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hszofficial.faiss_rpc.BatchResponse.batch_id)
}
#if LANG_CXX11
inline void BatchResponse::set_batch_id(::std::string&& value) {
  
  batch_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hszofficial.faiss_rpc.BatchResponse.batch_id)
}
#endif
inline void BatchResponse::set_batch_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hszofficial.faiss_rpc.BatchResponse.batch_id)
}
inline void BatchResponse::set_batch_id(const char* value, size_t size) {
  
  batch_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hszofficial.faiss_rpc.BatchResponse.batch_id)
}
inline ::std::string* BatchResponse::mutable_batch_id() {
  
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchResponse.batch_id)
  return batch_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchResponse::release_batch_id() {
  // @@protoc_insertion_point(field_release:hszofficial.faiss_rpc.BatchResponse.batch_id)
  
  return batch_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchResponse::set_allocated_batch_id(::std::string* batch_id) {
  if (batch_id != NULL) {
    
  } else {
    
  }
  batch_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), batch_id);
  // @@protoc_insertion_point(field_set_allocated:hszofficial.faiss_rpc.BatchResponse.batch_id)
}

// repeated .hszofficial.faiss_rpc.TopK result = 3;
inline int BatchResponse::result_size() const {
  return result_.size();
}
inline void BatchResponse::clear_result() {
  result_.Clear();
}
inline ::hszofficial::faiss_rpc::TopK* BatchResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:hszofficial.faiss_rpc.BatchResponse.result)
  return result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::TopK >*
BatchResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:hszofficial.faiss_rpc.BatchResponse.result)
  return &result_;
}
inline const ::hszofficial::faiss_rpc::TopK& BatchResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:hszofficial.faiss_rpc.BatchResponse.result)
  return result_.Get(index);
}
inline ::hszofficial::faiss_rpc::TopK* BatchResponse::add_result() {
  // @@protoc_insertion_point(field_add:hszofficial.faiss_rpc.BatchResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hszofficial::faiss_rpc::TopK >&
BatchResponse::result() const {
  // @@protoc_insertion_point(field_list:hszofficial.faiss_rpc.BatchResponse.result)
  return result_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace faiss_rpc
}  // namespace hszofficial

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hszofficial::faiss_rpc::ResponseStatus_Stat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hszofficial::faiss_rpc::ResponseStatus_Stat>() {
  return ::hszofficial::faiss_rpc::ResponseStatus_Stat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_faiss_5frpc_2eproto
